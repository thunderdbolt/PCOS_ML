# ========================
#  PCOS Detection Tool v2
# ========================

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.figure_factory as ff
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report, roc_auc_score
from sklearn.decomposition import PCA
from fpdf import FPDF
from PIL import Image
import urllib.request
import tempfile
import os

# -------------------- Page Setup --------------------
st.set_page_config(page_title="PCOS Detection Tool v2", layout="wide")
st.title("üß¨ PCOS Detection ‚Äì Real Data Model (Tool v2)")

# -------------------- Data Upload --------------------
st.sidebar.header("üì§ Upload Real Survey Data")
uploaded_file = st.sidebar.file_uploader("Upload CSV", type=["csv"])
if uploaded_file is None:
    st.info("Please upload a CSV file containing real survey responses.")
    st.stop()

data = pd.read_csv(uploaded_file)
st.subheader("üìã Uploaded Data Preview")
st.dataframe(data)

# -------------------- Preprocessing --------------------
st.subheader("üß™ Data Cleaning & Feature Preparation")
data = data.copy()
data = data.apply(lambda x: x.str.strip() if x.dtype == "object" else x)

bool_cols = [
    'irregular_periods', 'acne', 'hirsutism', 'hair_loss', 'baldness',
    'weight_gain', 'pelvic_pain', 'fatigue', 'sleep_difficulty',
    'mood_changes', 'mental_health_dx', 'smoking', 'caffeine',
    'supplements', 'medication_pcos', 'family_history_pcos',
    'family_history_medical'
]
cat_cols = [
    'diet_quality', 'diet_type', 'meal_frequency', 'eating_speed',
    'sugary_drinks', 'physical_activity', 'sports_type', 'sleep_hours',
    'water_intake', 'dairy'
]
for col in bool_cols:
    if col in data.columns:
        data[col] = data[col].astype(str).str.lower().map({'yes': 1, 'no': 0, 'true': 1, 'false': 0})
for col in cat_cols:
    if col in data.columns:
        data[col] = data[col].astype(str).str.strip()

data = pd.get_dummies(data, columns=[c for c in cat_cols if c in data.columns], drop_first=True)
non_feature_cols = ['pcos_onset_age', 'family_conditions']
features = data.drop(columns=[col for col in non_feature_cols if col in data.columns] + ['has_pcos'], errors='ignore')
target = data['has_pcos'] if 'has_pcos' in data.columns else None

# --- PDF Report Generator ---
# Enhanced PDF generator with logo and styled layout
def generate_clinical_pdf_report(input_df, prediction, confidence, feature_importance_df):
    # Download logo
    logo_url = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ7TmfIutY-gpYCpl4Bl-lhSKWcHlglDarrRA&s"
    logo_path = tempfile.NamedTemporaryFile(delete=False, suffix=".png").name
    urllib.request.urlretrieve(logo_url, logo_path)

    # Initialize PDF
    pdf = FPDF()
    pdf.add_page()

    # Add logo and title
    pdf.image(logo_path, x=10, y=8, w=25)
    pdf.set_font("Arial", "B", 18)
    pdf.cell(200, 10, txt="PCOS Clinical Evaluation Report", ln=True, align='C')
    pdf.set_font("Arial", "", 12)
    pdf.cell(200, 10, txt="Generated by PCOS Diagnostic Tool v2", ln=True, align='C')
    pdf.ln(10)

    # Prediction results
    pdf.set_font("Arial", "B", 14)
    pdf.cell(200, 10, txt="Prediction Summary", ln=True)
    pdf.set_font("Arial", "", 12)
    diagnosis = "Likely PCOS" if prediction == 1 else "Unlikely PCOS"
    pdf.set_text_color(200 if prediction == 1 else 34, 0, 0)
    pdf.cell(200, 10, txt=f"Diagnosis: {diagnosis}", ln=True)
    pdf.set_text_color(0, 0, 0)
    pdf.cell(200, 8, txt=f"Model Confidence: {confidence*100:.2f}%", ln=True)
    pdf.ln(5)

    # Patient input values
    pdf.set_font("Arial", "B", 13)
    pdf.cell(200, 10, txt="Patient Input Overview", ln=True)
    pdf.set_font("Arial", "", 11)

    for col, val in input_df.iloc[0].items():
        label = col.replace("_", " ").capitalize()
        pdf.cell(90, 8, txt=f"{label}:", border=0)
        pdf.cell(30, 8, txt=str(val), ln=True)

    pdf.ln(5)

    # Feature importance
    pdf.set_font("Arial", "B", 13)
    pdf.cell(200, 10, txt="Top 10 Contributing Features", ln=True)
    pdf.set_font("Arial", "", 11)

    for i, row in feature_importance_df.head(10).iterrows():
        label = row['Feature'].replace("_", " ").capitalize()
        pdf.cell(140, 8, txt=f"{label}", border=0)
        pdf.cell(30, 8, txt=f"{row['Importance']:.4f}", ln=True)

    # Save and return
    tmp_path = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf").name
    pdf.output(tmp_path)
    os.remove(logo_path)
    return tmp_path


# --- Train Model ---
if target is not None:
    X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.2, stratify=target, random_state=42)
    X_train = X_train.apply(pd.to_numeric, errors='coerce').fillna(0)
    X_test = X_test.apply(pd.to_numeric, errors='coerce').fillna(0)

    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    st.subheader("üìà Model Evaluation")
    y_pred = model.predict(X_test)
    y_prob = model.predict_proba(X_test)[:, 1]

    acc = accuracy_score(y_test, y_pred)
    roc = roc_auc_score(y_test, y_prob)
    cm = confusion_matrix(y_test, y_pred)
    report = classification_report(y_test, y_pred, output_dict=True)

    col1, col2, col3 = st.columns([3, 2, 3])
    with col1:
        plt.figure(figsize=(5, 4))
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['No PCOS', 'PCOS'], yticklabels=['No PCOS', 'PCOS'])
        plt.xlabel("Predicted")
        plt.ylabel("Actual")
        st.pyplot(plt.gcf())

    with col2:
        st.metric("Accuracy", f"{acc*100:.2f}%")
        st.metric("ROC-AUC", f"{roc:.2f}")
    with col3:
        st.subheader("üìù Classification Report")
        st.dataframe(pd.DataFrame(report).T.round(2))

    # --- Feature Importance (Horizontal Bar Chart) ---
    # Enhanced version of the form with tooltips, collapsible sections, and input grouping

    def generate_grouped_input_form(X_train):
        st.sidebar.markdown("## üß† Manual Patient Input (All Features)")
        user_inputs = {}

        grouped_inputs = {
            "üìä Basic Information": ["age", "bmi", "height_cm", "weight_kg", "waist_size"],
            "ü©∫ Symptoms": [col for col in X_train.columns if any(sym in col for sym in ["acne", "hirsutism", "fatigue", "pelvic_pain", "hair_loss", "baldness", "irregular_periods", "sleep_difficulty", "mood_changes"])],
            "üíâ Medical History": [col for col in X_train.columns if "family" in col or "mental_health" in col or "medication" in col or "supplements" in col],
            "ü•ó Lifestyle & Diet": [col for col in X_train.columns if any(k in col for k in ["diet_", "sugary_drinks", "physical_activity", "caffeine", "water_intake", "sleep_hours", "sports_type", "meal_frequency", "eating_speed", "dairy"])],
        }

        with st.sidebar.form("full_patient_input_form"):
            for section, fields in grouped_inputs.items():
                with st.expander(section, expanded=False):
                    for col in fields:
                        label = col.replace("_", " ").title()
                        if col in ["age", "bmi", "waist_size", "height_cm", "weight_kg"]:
                            user_inputs[col] = st.number_input(f"{label}", min_value=0.0, step=1.0)
                        elif X_train[col].nunique() == 2 and set(X_train[col].unique()).issubset({0, 1}):
                            user_inputs[col] = st.checkbox(f"{label}")
                        else:
                            user_inputs[col] = st.number_input(f"{label}", value=0.0, step=1.0)

            submitted = st.form_submit_button("üîé Predict")

        return user_inputs if submitted else None

    # Prediction + Export option
    if 'model' in locals() and 'X_train' in locals():
        input_dict = generate_grouped_input_form(X_train)

        # --- Feature Importance (Horizontal Bar Chart) ---
        # st.subheader("üîç Feature Importance (Top 15)")
        importances = pd.Series(model.feature_importances_, index=features.columns).sort_values(ascending=False)

        if input_dict is not None:
            model_features = X_train.columns
            input_data = pd.DataFrame([{col: int(input_dict.get(col, 0)) for col in model_features}])

            # Prediction
            pred = int(model.predict(input_data)[0])
            proba = model.predict_proba(input_data)[0]
            confidence = proba[pred]

            st.sidebar.markdown("---")
            if pred == 1:
                st.sidebar.error(f"üö® Likely PCOS\nConfidence: {confidence:.2f}")
            else:
                st.sidebar.success(f"‚úÖ Unlikely PCOS\nConfidence: {confidence:.2f}")

        # Re-attach PDF export if prediction exists
        if 'input_data' in locals() and 'pred' in locals() and 'confidence' in locals() and 'importances' in locals():
            st.sidebar.markdown("### üßæ Export Professional Report")
            importance_df = pd.DataFrame({
                "Feature": importances.index,
                "Importance": importances.values
            }).sort_values(by="Importance", ascending=False)

            report_path = generate_clinical_pdf_report(input_data, pred, confidence, importance_df)
            with open(report_path, "rb") as f:
                st.sidebar.download_button(
                    label="Download PDF Report",
                    data=f,
                    file_name="pcos_clinical_report.pdf",
                    mime="application/pdf"
                )
            os.remove(report_path)

    cola, colb = st.columns([2, 3])
    # Generate additional insights and visualizations
    def generate_visual_insights(data):
        # st.subheader("üìä Additional Insights from Data")
        with cola:
            # Target distribution
            if 'has_pcos' in data.columns:
                st.markdown("### üß¨ PCOS Distribution")
                pcos_count = data['has_pcos'].value_counts().rename({0: 'No PCOS', 1: 'PCOS'})
                fig1, ax1 = plt.subplots()
                ax1.pie(pcos_count, labels=pcos_count.index, autopct='%1.1f%%', startangle=90, colors=['#66b3ff','#ff9999'])
                ax1.axis('equal')
                st.pyplot(fig1)

            # Correlation heatmap
            st.markdown("")
            st.markdown("")
            st.markdown("### üìà Feature Correlation Heatmap")
            st.markdown("")
            numeric_data = data.select_dtypes(include=[np.number]).copy()
            if numeric_data.shape[1] > 1:
                corr = numeric_data.corr()
                fig2, ax2 = plt.subplots(figsize=(10, 8))
                sns.heatmap(corr, cmap="coolwarm", center=0, annot=False, fmt=".2f", linewidths=0.5)
                st.pyplot(fig2)

            # Distribution plots for top features
            st.markdown("### üìå Distribution of Selected Features")
            selected_features = ["bmi", "age", "weight_kg", "waist_size"]
            for feature in selected_features:
                if feature in data.columns:
                    fig3, ax3 = plt.subplots()
                    sns.histplot(data=data, x=feature, hue=data['has_pcos'] if 'has_pcos' in data.columns else None, kde=True, ax=ax3)
                    ax3.set_title(f"Distribution of {feature.title()} by PCOS Status")
                    st.pyplot(fig3)

    # Run only if data is present
    if 'data' in locals() and isinstance(data, pd.DataFrame):
        generate_visual_insights(data)


    # Enhanced interactive visualizations using Plotly
    # Patch the pie chart bug in the interactive insights function
    with colb:
        def generate_interactive_visual_insights(data):
            # st.subheader("üìä Interactive Data Insights")

            # --- PCOS Distribution Pie Chart ---
            if 'has_pcos' in data.columns:
                st.markdown("### üß¨ PCOS Distribution (Interactive)")
                pcos_labels = {0: "No PCOS", 1: "PCOS"}
                pcos_counts = data['has_pcos'].map(pcos_labels).value_counts().reset_index()
                pcos_counts.columns = ['PCOS Status', 'Count']
                fig_pie = px.pie(pcos_counts, names='PCOS Status', values='Count', title="PCOS Class Distribution", hole=0.4)
                st.plotly_chart(fig_pie)

            # --- Correlation Heatmap (Plotly Heatmap) ---
            st.markdown("### üìà Feature Correlation Heatmap (Interactive)")
            numeric_df = data.select_dtypes(include=[np.number])
            if numeric_df.shape[1] > 1:
                corr_matrix = numeric_df.corr().round(2)
                fig_heatmap = px.imshow(corr_matrix,
                                        text_auto=True,
                                        aspect="auto",
                                        color_continuous_scale="RdBu_r",
                                        title="Correlation Between Numeric Features")
                st.plotly_chart(fig_heatmap)

            # --- Distribution of Selected Features ---
            st.markdown("")
            st.markdown("")
            st.markdown("")
            st.markdown("### üìå Feature Distributions by PCOS Status (Interactive)")
            if 'has_pcos' in data.columns:
                selected_features = ['bmi', 'age', 'weight_kg', 'waist_size']
                for col in selected_features:
                    if col in data.columns:
                        fig_hist = px.histogram(data, x=col, color='has_pcos',
                                                barmode='overlay',
                                                color_discrete_map={0: "skyblue", 1: "salmon"},
                                                title=f"{col.title()} Distribution by PCOS Status")
                        fig_hist.update_traces(opacity=0.6)
                        st.plotly_chart(fig_hist)

        # Re-run if data is loaded
        if 'data' in locals() and isinstance(data, pd.DataFrame):
            generate_interactive_visual_insights(data)


    def add_advanced_visuals(data):
        with cola:
            # st.subheader("üß† Advanced Visual Insights")

            numeric_df = data.select_dtypes(include=[np.number]).dropna()
            label_col = 'has_pcos' if 'has_pcos' in numeric_df.columns else None

            # --- 3D Scatter Plot ---
            st.markdown("### üéØ 3D Scatter Plot: Age vs BMI vs Waist Size")
            if all(col in numeric_df.columns for col in ['age', 'bmi', 'waist_size']) and label_col:
                fig_3d = px.scatter_3d(
                    numeric_df,
                    x='age',
                    y='bmi',
                    z='waist_size',
                    color=label_col,
                    title="3D Plot: Age, BMI, Waist Size by PCOS Status",
                    color_discrete_map={0: "skyblue", 1: "salmon"}
                )
                st.plotly_chart(fig_3d)
        with colb:
            # --- PCA Plot ---
            st.markdown("### üî¨ Dimensionality Reduction (PCA)")
            if label_col and numeric_df.shape[1] > 3:
                features_only = numeric_df.drop(columns=[label_col])
                pca = PCA(n_components=2)
                components = pca.fit_transform(features_only)
                pca_df = pd.DataFrame(components, columns=["PC1", "PC2"])
                pca_df[label_col] = numeric_df[label_col].values

                fig_pca = px.scatter(
                    pca_df,
                    x="PC1",
                    y="PC2",
                    color=label_col,
                    title="PCA: Visualizing Clusters by PCOS",
                    color_discrete_map={0: "skyblue", 1: "salmon"}
                )
                st.plotly_chart(fig_pca)

    # Run if data is ready
    if 'data' in locals() and isinstance(data, pd.DataFrame):
        add_advanced_visuals(data)



    # Add model comparison and hyperparameter tuning
    def add_model_comparison_and_tuning(X_train, X_test, y_train, y_test):
        st.subheader("‚öñÔ∏è Model Comparison & Tuning")
        colc, cold = st.columns([2,3])
        models = {
            "Random Forest": RandomForestClassifier(random_state=42),
            "Logistic Regression": LogisticRegression(max_iter=1000, solver='liblinear'),
            "SVM": SVC(probability=True, kernel='rbf')
        }

        results = []

        for name, model in models.items():
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            y_prob = model.predict_proba(X_test)[:, 1]

            results.append({
                "Model": name,
                "Accuracy": round(accuracy_score(y_test, y_pred), 3),
                "ROC AUC": round(roc_auc_score(y_test, y_prob), 3)
            })

        results_df = pd.DataFrame(results)
        with colc:
            st.markdown("### üìä Performance Summary")
            st.dataframe(results_df, hide_index=True)
        with cold:
            # Hyperparameter tuning (Random Forest)
            st.markdown("### üõ†Ô∏è Hyperparameter Tuning: Random Forest")
            param_grid = {
                "n_estimators": [50, 100],
                "max_depth": [None, 10, 20],
                "min_samples_split": [2, 5]
            }

            grid = GridSearchCV(RandomForestClassifier(random_state=42), param_grid, cv=3, scoring='roc_auc', n_jobs=-1)
            grid.fit(X_train, y_train)

            st.markdown(f"**Best Parameters:** `{grid.best_params_}`")
            st.markdown(f"**Best ROC AUC:** `{grid.best_score_:.3f}`")

    # Run if model & data available
    try:
        add_model_comparison_and_tuning(X_train, X_test, y_train, y_test)
    except NameError:
        st.warning("‚ö†Ô∏è Training data not available. Please upload and preprocess your dataset first.")
